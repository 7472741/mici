<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>mici.samplers API documentation</title>
<meta name="description" content="Monte Carlo sampler classes for peforming inference." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>mici.samplers</code></h1>
</header>
<section id="section-intro">
<p>Monte Carlo sampler classes for peforming inference.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L0-L828" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Monte Carlo sampler classes for peforming inference.&#34;&#34;&#34;

import os
import logging
import tempfile
import signal
from collections import OrderedDict
import numpy as np
import mici
import mici.transitions as trans
from mici.states import ChainState
from mici.utils import get_size, get_valid_filename

try:
    import tqdm
    import tqdm.auto as tqdm_auto
    TQDM_AVAILABLE = True
except ImportError:
    TQDM_AVAILABLE = False
try:
    import randomgen
    RANDOMGEN_AVAILABLE = True
except ImportError:
    RANDOMGEN_AVAILABLE = False
# Preferentially import Pool from multiprocess library if available as able
# to serialise much wider range of types including autograd functions
try:
    from multiprocess import Pool
except ImportError:
    from multiprocessing import Pool


logger = logging.getLogger(__name__)


def _ignore_sigint_initialiser():
    &#34;&#34;&#34;Initialiser for multi-process workers to force ignoring SIGINT.&#34;&#34;&#34;
    signal.signal(signal.SIGINT, signal.SIG_IGN)


class MarkovChainMonteCarloMethod(object):
    &#34;&#34;&#34;Generic Markov chain Monte Carlo (MCMC) sampler.

    Generates a Markov chain from some initial state by iteratively applying
    a sequence of Markov transition operators.
    &#34;&#34;&#34;

    def __init__(self, rng, transitions):
        &#34;&#34;&#34;
        Args:
            rng: Numpy RandomState random number generator instance.
            transitions: Ordered dictionary of Markov chain transitions to
                sequentially sample from on each chain iteration.
        &#34;&#34;&#34;
        self.rng = rng
        self.transitions = transitions

    def _generate_memmap_filename(self, dir_path, prefix, key, index):
        key_str = get_valid_filename(str(key))
        if index is None:
            index = 0
        return os.path.join(dir_path, f&#39;{prefix}_{index}_{key_str}.npy&#39;)

    def _open_new_memmap(self, filename, shape, dtype, default_val):
        memmap = np.lib.format.open_memmap(
            filename, dtype=dtype, mode=&#39;w+&#39;, shape=shape)
        memmap[:] = default_val
        return memmap

    def _memmaps_to_filenames(self, obj):
        if isinstance(obj, np.memmap):
            return obj.filename
        elif isinstance(obj, dict):
            return {k: self._memmaps_to_filenames(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._memmaps_to_filenames(v) for v in obj]

    def _init_chain_stats(self, n_sample, memmap_enabled, memmap_path,
                          chain_index):
        chain_stats = {}
        for trans_key, trans in self.transitions.items():
            chain_stats[trans_key] = {}
            if hasattr(trans, &#39;statistic_types&#39;):
                for key, (dtype, val) in trans.statistic_types.items():
                    if memmap_enabled:
                        filename = self._generate_memmap_filename(
                            memmap_path, &#39;stats&#39;, f&#39;{trans_key}_{key}&#39;,
                            chain_index)
                        chain_stats[trans_key][key] = self._open_new_memmap(
                            filename, (n_sample,), dtype, val)
                    else:
                        chain_stats[trans_key][key] = np.full(
                            n_sample, val, dtype)
        return chain_stats

    def _sample_chain(self, rng, n_sample, init_state, trace_funcs,
                      chain_index, parallel_chains, memmap_enabled=False,
                      memmap_path=None, monitor_stats=None):
        for trans_key, transition in self.transitions.items():
            for var_key in transition.state_variables:
                if var_key not in init_state:
                    raise ValueError(
                        f&#39;init_state does contain have {var_key} value &#39;
                        f&#39;required by {trans_key} transition.&#39;)
        if not isinstance(init_state, (ChainState, dict)):
            raise TypeError(
                &#39;init_state should be a dictionary or `ChainState`.&#39;)
        state = (ChainState(**init_state) if isinstance(init_state, dict)
                 else init_state)
        chain_stats = self._init_chain_stats(
            n_sample, memmap_enabled, memmap_path, chain_index)
        # Initialise chain trace arrays
        traces = {}
        for trace_func in trace_funcs:
            for key, val in trace_func(state).items():
                val = np.array(val) if np.isscalar(val) else val
                init = np.nan if np.issubdtype(val.dtype, np.inexact) else 0
                if memmap_enabled:
                    filename = self._generate_memmap_filename(
                        memmap_path, &#39;trace&#39;, key, chain_index)
                    traces[key] = self._open_new_memmap(
                        filename, (n_sample,) + val.shape, val.dtype, init)
                else:
                    traces[key] = np.full(
                        (n_sample,) + val.shape, init, val.dtype)
        total_return_nbytes = get_size(chain_stats) + get_size(traces)
        # Check if running in parallel and if total number of bytes to be
        # returned exceeds pickle limit
        if parallel_chains and total_return_nbytes &gt; 2**31 - 1:
            raise RuntimeError(
                f&#39;Total number of bytes allocated for arrays to be returned &#39;
                f&#39;({total_return_nbytes / 2**30:.2f} GiB) exceeds size limit &#39;
                f&#39;for returning results of a process (2 GiB). Try rerunning &#39;
                f&#39;with chain memory-mapping enabled (`memmap_enabled=True`).&#39;)
        if TQDM_AVAILABLE:
            kwargs = {
                &#39;desc&#39;: f&#39;Chain {0 if chain_index is None else chain_index}&#39;,
                &#39;unit&#39;: &#39;it&#39;,
                &#39;dynamic_ncols&#39;: True,
            }
            if parallel_chains:
                sample_range = tqdm_auto.trange(
                    n_sample, **kwargs, position=chain_index)
            else:
                sample_range = tqdm.trange(n_sample, **kwargs)
        else:
            sample_range = range(n_sample)
        try:
            for sample_index in sample_range:
                for trans_key, transition in self.transitions.items():
                    state, trans_stats = transition.sample(state, rng)
                    if trans_stats is not None:
                        if trans_key not in chain_stats:
                            logger.warning(
                                f&#39;Transition {trans_key} returned statistics &#39;
                                f&#39;but has no `statistic_types` attribute.&#39;)
                        for key, val in trans_stats.items():
                            if key in chain_stats[trans_key]:
                                chain_stats[trans_key][key][sample_index] = val
                for trace_func in trace_funcs:
                    for key, val in trace_func(state).items():
                        traces[key][sample_index] = val
                if TQDM_AVAILABLE and monitor_stats is not None:
                    postfix_stats = {}
                    for (trans_key, stats_key) in monitor_stats:
                        if (trans_key not in chain_stats or
                                stats_key not in chain_stats[trans_key]):
                            logger.warning(
                                f&#39;Statistics key pair {(trans_key, stats_key)}&#39;
                                f&#39; to be monitored is not valid.&#39;)
                        print_key = f&#39;mean({stats_key})&#39;
                        postfix_stats[print_key] = np.mean(
                            chain_stats[trans_key][stats_key][:sample_index+1])
                    sample_range.set_postfix(postfix_stats)
        except KeyboardInterrupt:
            if memmap_enabled:
                for trace in traces.values():
                    trace.flush()
                for trans_stats in chain_stats.values():
                    for stat in trans_stats.values():
                        stat.flush()
        else:
            # If not interrupted increment sample_index so that it equals
            # n_sample to flag chain completed sampling
            sample_index += 1
        if parallel_chains and memmap_enabled:
                trace_filenames = self._memmaps_to_filenames(traces)
                stats_filenames = self._memmaps_to_filenames(chain_stats)
                return trace_filenames, stats_filenames, sample_index
        return state, traces, chain_stats, sample_index

    def __preprocess_kwargs(self, kwargs):
        if &#39;memmap_enabled&#39; not in kwargs:
            kwargs[&#39;memmap_enabled&#39;] = False
        # Create temporary directory if memory mapping and no path provided
        if kwargs[&#39;memmap_enabled&#39;] and &#39;memmap_path&#39; not in kwargs:
            kwargs[&#39;memmap_path&#39;] = tempfile.mkdtemp()
        return kwargs

    def sample_chain(self, n_sample, init_state, trace_funcs, **kwargs):
        &#34;&#34;&#34;Sample a Markov chain from a given initial state.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_state (ChainState or dict): Initial chain state. Either a
                `ChainState` object or a dictionary with entries specifying
                initial values for all state variables used by chain
                transition `sample` methods.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored.

        Kwargs:
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
                key pairs, with first entry the key of a Markov transition in
                the `transitions` dict passed to the the `__init__` method and
                the second entry the key of a chain statistic that will be
                returned in the `chain_stats` dictionary. The mean over samples
                computed so far of the chain statistics associated with any
                valid key-pairs will be monitored during sampling  by printing
                as postfix to progress bar (if `tqdm` is installed).

        Returns:
            final_state (ChainState): State of chain after final iteration. May
                be used to resume sampling a chain by passing as the initial
                state to a new `sample_chain` call.
            traces (dict[str, array]): Dictionary of chain trace arrays. Values
                in dictionary are arrays of variables outputted by trace
                functions in `trace_funcs` with leading dimension of array
                corresponding to the sampling (draw) index. The key for each
                value is the corresponding key in the dictionary returned by
                the trace function which computed the traced value.
            chain_stats (dict[str, dict[str, array]]): Dictionary of chain
                transition statistic dictionaries. Values in outer dictionary
                are dictionaries of statistics for each chain transition, keyed
                by the string key for the transition. The values in each inner
                transition dictionary are arrays of chain statistic values with
                the leading dimension of each array corresponding to the
                sampling (draw) index. The key for each value is a string
                description of the corresponding integration transition
                statistic.
        &#34;&#34;&#34;
        kwargs = self.__preprocess_kwargs(kwargs)
        final_state, traces, chain_stats, sample_index = self._sample_chain(
            rng=self.rng, n_sample=n_sample, init_state=init_state,
            trace_funcs=trace_funcs, chain_index=None, parallel_chains=False,
            **kwargs)
        if sample_index != n_sample:
            # Sampling interrupted therefore truncate returned arrays
            # Using resize methods makes agnostic to whether array is
            # memory mapped or not
            for trans_stats in chain_stats.values():
                for key in trans_stats:
                    trans_stats[key].resize(
                        (sample_index,) + trans_stats[key].shape[1:])
            for key in traces:
                traces[key].resize(
                    (sample_index,) + traces[key].shape[1:])
            logger.error(
                f&#39;Sampling manually interrupted at iteration {sample_index}. &#39;
                f&#39;Arrays containing chain traces and statistics computed &#39;
                f&#39;before interruption will be returned.&#39;)
        return final_state, traces, chain_stats

    def _collate_chain_outputs(self, n_sample, chain_outputs, load_memmaps):
        final_states_stack = []
        traces_stack = {}
        n_chain = len(chain_outputs)
        chain_stats_stack = {}
        for chain_index, chain_output in enumerate(chain_outputs):
            final_state, traces, chain_stats, sample_index = chain_output
            final_states_stack.append(final_state)
            for key, val in traces.items():
                if load_memmaps:
                    val = np.lib.format.open_memmap(val)
                if sample_index != n_sample:
                    # Sampling interrupted therefore truncate returned arrays
                    # Using resize methods makes agnostic to whether array is
                    # memory mapped or not
                    val.resize((sample_index,) + val.shape[1:], refcheck=False)
                if chain_index == 0:
                    traces_stack[key] = [val]
                else:
                    traces_stack[key].append(val)
            for trans_key, trans_stats in chain_stats.items():
                if chain_index == 0:
                    chain_stats_stack[trans_key] = {}
                for key, val in trans_stats.items():
                    if load_memmaps:
                        val = np.lib.format.open_memmap(val)
                    if sample_index != n_sample:
                        # Sampling interrupted therefore truncate returned
                        # arrays Using resize methods makes agnostic to whether
                        # array is memory mapped or not
                        val.resize((sample_index,) + val.shape[1:],
                                   refcheck=False)
                    if chain_index == 0:
                        chain_stats_stack[trans_key][key] = [val]
                    else:
                        chain_stats_stack[trans_key][key].append(val)
        return final_states_stack, traces_stack, chain_stats_stack

    def sample_chains(self, n_sample, init_states, trace_funcs, n_process=1,
                      **kwargs):
        &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.
        The chains may be run in parallel across multiple independent processes
        or sequentially. In all cases all chains use independent random draws.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_states (Iterable[ChainState] or Iterable[dict]): Initial
                chain states. Each entry can be either a `ChainState` object or
                a dictionary with entries specifying initial values for all
                state variables used by chain transition `sample` methods.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored.
            n_process (int or None): Number of parallel processes to run chains
                over. If set to one then chains will be run sequentially in
                otherwise a `multiprocessing.Pool` object will be used to
                dynamically assign the chains across multiple processes. If
                set to `None` then the number of processes will default to the
                output of `os.cpu_count()`.

        Kwargs:
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
                key pairs, with first entry the key of a Markov transition in
                the `transitions` dict passed to the the `__init__` method and
                the second entry the key of a chain statistic that will be
                returned in the `chain_stats` dictionary. The mean over samples
                computed so far of the chain statistics associated with any
                valid key-pairs will be monitored during sampling  by printing
                as postfix to progress bar (if `tqdm` is installed).

        Returns:
            final_states (list[ChainState]): States of chains after final
                iteration. May be used to resume sampling a chain by passing as
                the initial states to a new `sample_chains` call.
            traces (dict[str, list[array]]): Dictionary of chain trace arrays.
                Values in dictionary are list of arrays of variables outputted
                by trace functions in `trace_funcs` with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is the corresponding key in the dictionary
                returned by the trace function which computed the traced value.
            chain_stats (dict[str, dict[str, list[array]]]): Dictionary of
                chain transition statistic dictionaries. Values in outer
                dictionary are dictionaries of statistics for each chain
                transition, keyed by the string key for the transition. The
                values in each inner transition dictionary are lists of arrays
                of chain statistic values with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is a string description of the corresponding
                integration transition statistic.
        &#34;&#34;&#34;
        n_chain = len(init_states)
        kwargs = self.__preprocess_kwargs(kwargs)
        if RANDOMGEN_AVAILABLE:
            seed = self.rng.randint(2**64, dtype=&#39;uint64&#39;)
            rngs = [randomgen.Xorshift1024(seed).jump(i).generator
                    for i in range(n_chain)]
        else:
            seeds = (self.rng.choice(2**16, n_chain, False) * 2**16 +
                     self.rng.choice(2**16, n_chain, False))
            rngs = [np.random.RandomState(seed) for seed in seeds]
        chain_outputs = []
        shared_kwargs_list = [{
                &#39;rng&#39;: rng,
                &#39;n_sample&#39;: n_sample,
                &#39;init_state&#39;: init_state,
                &#39;trace_funcs&#39;: trace_funcs,
                &#39;chain_index&#39;: c,
                **kwargs
            } for c, (rng, init_state) in enumerate(zip(rngs, init_states))]
        if n_process == 1:
            # Using single process therefore run chains sequentially
            for c, shared_kwargs in enumerate(shared_kwargs_list):
                final_state, traces, stats, sample_index = self._sample_chain(
                    **shared_kwargs, parallel_chains=False)
                chain_outputs.append(
                    (final_state, traces, stats, sample_index))
                if sample_index != n_sample:
                    logger.error(
                        f&#39;Sampling manually interrupted at chain {c} iteration&#39;
                        f&#39; {sample_index}. Arrays containing chain traces&#39;
                        f&#39; and statistics computed before interruption will&#39;
                        f&#39; be returned.&#39;)
                    break
        else:
            # Run chains in parallel using a multiprocess(ing).Pool
            # Child processes made to ignore SIGINT signals to allow handling
            # of KeyboardInterrupts in parent process
            n_completed = 0
            pool = Pool(n_process, _ignore_sigint_initialiser)
            try:
                results = [
                    pool.apply_async(
                        self._sample_chain,
                        kwds=dict(**shared_kwargs, parallel_chains=True))
                    for shared_kwargs in shared_kwargs_list]
                for result in results:
                    chain_outputs.append(result.get())
                    n_completed += 1
            except KeyboardInterrupt:
                # Close any still running processes
                pool.terminate()
                pool.join()
                err_message = &#39;Sampling manually interrupted.&#39;
                if n_completed &gt; 0:
                    err_message += (
                        f&#39; Data for {n_completed} completed chains will be &#39;
                        f&#39;returned.&#39;)
                if kwargs[&#39;memmap_enabled&#39;]:
                    err_message += (
                        f&#39; All data recorded so far including in progress &#39;
                        f&#39;chains is available in directory &#39;
                        f&#39;{kwargs[&#34;memmap_path&#34;]}.&#39;)
                logger.error(err_message)
        # When running parallel jobs with memory-mapping enabled, data arrays
        # returned by processes as file paths to array memory-maps therfore
        # load memory-maps objects from file before returing results
        load_memmaps = kwargs[&#39;memmap_enabled&#39;] and n_process &gt; 1
        return self._collate_chain_outputs(
            n_sample, chain_outputs, load_memmaps)


class HamiltonianMCMC(MarkovChainMonteCarloMethod):
    &#34;&#34;&#34;Wrapper class for Hamiltonian Markov chain Monte Carlo (H-MCMC) methods.

    Here H-MCMC is defined as a MCMC method which augments the original target
    variable (henceforth position variable) with a momentum variable with a
    user specified conditional distribution given the position variable. In
    each chain iteration two Markov transitions leaving the resulting joint
    distribution on position and momentum variables invariant are applied -
    the momentum variables are updated in a transition which leaves their
    conditional distribution invariant (momentum transition) and then a
    trajectory in the joint space is generated by numerically integrating a
    Hamiltonian dynamic with an appropriate symplectic integrator which is
    exactly reversible, volume preserving and approximately conserves the joint
    probability density of the target-momentum state pair; one state from the
    resulting trajectory is then selected as the next joint chain state using
    an appropriate sampling scheme such that the joint distribution is left
    exactly invariant (integration transition).

    There are various options available for both the momentum transition and
    integration transition, with by default the momentum transition set to be
    independent resampling of the momentum variables from their conditional
    distribution.

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, rng, integration_transition,
                 momentum_transition=None):
        &#34;&#34;&#34;
        Args:
            system: Hamiltonian system to be simulated.
            rng: Numpy RandomState random number generator instance.
            integration_transition: Markov transition operator which jointly
                updates the position and momentum components of the chain
                state by integrating the Hamiltonian dynamics of the system
                to propose new values for the state.
            momentum_transition: Markov transition operator which updates only
                the momentum component of the chain state. If set to `None` a
                transition operator which independently samples the momentum
                from its conditional distribution will be used.
        &#34;&#34;&#34;
        self.system = system
        self.rng = rng
        if momentum_transition is None:
            momentum_transition = trans.IndependentMomentumTransition(system)
        super().__init__(rng, OrderedDict(
            momentum_transition=momentum_transition,
            integration_transition=integration_transition))

    def _preprocess_init_state(self, init_state):
        &#34;&#34;&#34;Make sure initial state is a ChainState and has momentum.&#34;&#34;&#34;
        if isinstance(init_state, np.ndarray):
            # If array use to set position component of new ChainState
            init_state = ChainState(pos=init_state, mom=None, dir=1)
        elif not isinstance(init_state, ChainState) or &#39;mom&#39; not in init_state:
            raise TypeError(
                &#39;init_state should be an array or `ChainState` with &#39;
                &#39;`mom` attribute.&#39;)
        if init_state.mom is None:
            init_state.mom = self.system.sample_momentum(init_state, self.rng)
        return init_state

    def __preprocess_kwargs(self, kwargs):
        # default to tracing only position component of state
        if &#39;trace_funcs&#39; not in kwargs:
            kwargs[&#39;trace_funcs&#39;] = [lambda state: {&#39;pos&#39;: state.pos}]
        # if `monitor_stats` specified, expand all statistics keys to key pairs
        # with transition key set to `integration_transition`
        if &#39;monitor_stats&#39; in kwargs:
            kwargs[&#39;monitor_stats&#39;] = [
                (&#39;integration_transition&#39;, stats_key)
                for stats_key in kwargs[&#39;monitor_stats&#39;]]
        else:
            kwargs[&#39;monitor_stats&#39;] = [
                (&#39;integration_transition&#39;, &#39;accept_prob&#39;)]
        return kwargs

    def sample_chain(self, n_sample, init_state, **kwargs):
        &#34;&#34;&#34;Sample a Markov chain from a given initial state.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_state (ChainState or array): Initial chain state. The state
                can be either an array specifying the state position component
                or a `ChainState` instance. If an array is passed or the `mom`
                attribute of the state is not set, a momentum component will be
                independently sampled from its conditional distribution.

        Kwargs:
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored. Default is for a single trace function
                which records the `pos` component of the state.
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[str]): List of string keys of chain
                statistics to monitor mean of over samples computed so far
                during sampling by printing as postfix to progress bar (if
                `tqdm` is installed). Default is to print only the mean
                `accept_prob` statistic.

        Returns:
            final_state (ChainState): State of chain after final iteration. May
                be used to resume sampling a chain by passing as the initial
                state to a new `sample_chain` call.
            traces (dict[str, array]): Dictionary of chain trace arrays. Values
                in dictionary are arrays of variables outputted by trace
                functions in `trace_funcs` with leading dimension of array
                corresponding to the sampling (draw) index. The key for each
                value is the corresponding key in the dictionary returned by
                the trace function which computed the traced value.
            chain_stats (dict[str, array]): Dictionary of chain integration
                transition statistics. Values in dictionary are arrays of chain
                statistic values with the leading dimension of each array
                corresponding to the sampling (draw) index. The key for each
                value is a string description of the corresponding integration
                transition statistic.
        &#34;&#34;&#34;
        init_state = self._preprocess_init_state(init_state)
        kwargs = self.__preprocess_kwargs(kwargs)
        final_state, traces, chain_stats = super().sample_chain(
            n_sample, init_state, **kwargs)
        chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
        return final_state, traces, chain_stats

    def sample_chains(self, n_sample, init_states, **kwargs):
        &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

        Performs a specified number of chain iterations (each of consists of a
        momentum transition and integration transition), recording the outputs
        of functions of the sampled chain state after each iteration. The
        chains may be run in parallel across multiple independent processes or
        sequentially. In all cases all chains use independent random draws.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_states (Iterable[ChainState] or Iterable[array]): Initial
                chain states. Each state can be either an array specifying the
                state position component or a `ChainState` instance. If an
                array is passed or the `mom` attribute of the state is not set,
                a momentum component will be independently sampled from its
                conditional distribution. One chain will be run for each state
                in the iterable sequence.

        Kwargs:
            n_process (int or None): Number of parallel processes to run chains
                over. If set to one then chains will be run sequentially in
                otherwise a `multiprocessing.Pool` object will be used to
                dynamically assign the chains across multiple processes. If set
                to `None` then the number of processes will be set to the
                output of `os.cpu_count()`. Default is `n_process=1`.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored. Default is for a single trace function
                which records the `pos` component of the state.
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[str]): List of string keys of chain
                statistics to monitor mean of over samples computed so far
                during sampling by printing as postfix to progress bar (if
                `tqdm` is installed). Default is to print only the mean
                `accept_prob` statistic.

        Returns:
            final_states (list[ChainState]): States of chains after final
                iteration. May be used to resume sampling a chain by passing as
                the initial states to a new `sample_chains` call.
            traces (dict[str, list[array]]): Dictionary of chain trace arrays.
                Values in dictionary are list of arrays of variables outputted
                by trace functions in `trace_funcs` with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is the corresponding key in the dictionary
                returned by the trace function which computed the traced value.
            chain_stats (dict[str, list[array]]): Dictionary of chain
                integration transition statistics. Values in dictionary are
                lists of arrays of chain statistic values with each array in
                the list corresponding to a single chain and the leading
                dimension of each array corresponding to the sampling (draw)
                index. The key for each value is a string description of the
                corresponding integration transition statistic.
        &#34;&#34;&#34;
        init_states = [self._preprocess_init_state(i) for i in init_states]
        kwargs = self.__preprocess_kwargs(kwargs)
        final_states, traces, chain_stats = super().sample_chains(
            n_sample, init_states, **kwargs)
        chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
        return final_states, traces, chain_stats


class StaticMetropolisHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Static integration time H-MCMC implementation with Metropolis sampling.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a fixed integer number of integrator steps.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.

    This is original proposed Hybrid Monte Carlo (often now instead termed
    Hamiltonian Monte Carlo) algorithm [1,2].

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng, n_step,
                 momentum_transition=None):
        integration_transition = trans.MetropolisStaticIntegrationTransition(
            system, integrator, n_step)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def n_step(self):
        return self.transitions[&#39;integration_transition&#39;].n_step

    @n_step.setter
    def n_step(self, value):
        self.transitions[&#39;integration_transition&#39;].n_step = value


class RandomMetropolisHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Random integration time H-MCMC with Metropolis sampling of new state.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a random integer number of integrator steps sampled from the uniform
    distribution on an integer interval.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.

    The randomisation of the number of integration steps avoids the potential
    of the chain mixing poorly due to using an integration time close to the
    period of (near) periodic systems [1,2].

    References:

      1. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
      2. Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
         Physics Letters B, 226(3-4), pp.369-371.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng, n_step_range,
                 momentum_transition=None):
        integration_transition = trans.MetropolisRandomIntegrationTransition(
            system, integrator, n_step_range)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def n_step_range(self):
        return self.transitions[&#39;integration_transition&#39;].n_step_range

    @n_step_range.setter
    def n_step_range(self, value):
        self.transitions[&#39;integration_transition&#39;].n_step_range = value


class DynamicMultinomialHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Dynamic integration time H-MCMC with multinomial sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps
    equal to the previous tree size [1,2] until a termination criteria on the
    tree leaves is met. The next chain state is chosen from the candidate
    states using a progressive multinomial sampling scheme [2] based on the
    relative probability densities of the different candidate states, with the
    resampling biased towards states further from the current state.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng,
                 max_tree_depth=10, max_delta_h=1000,
                 termination_criterion=trans.riemannian_no_u_turn_criterion,
                 momentum_transition=None):
        integration_transition = trans.MultinomialDynamicIntegrationTransition(
            system, integrator, max_tree_depth, max_delta_h,
            termination_criterion)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def max_tree_depth(self):
        return self.transitions[&#39;integration_transition&#39;].max_tree_depth

    @max_tree_depth.setter
    def max_tree_depth(self, value):
        self.transitions[&#39;integration_transition&#39;].max_tree_depth = value

    @property
    def max_delta_h(self):
        return self.transitions[&#39;integration_transition&#39;].max_delta_h

    @max_delta_h.setter
    def max_delta_h(self, value):
        self.transitions[&#39;integration_transition&#39;].max_delta_h = value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mici.samplers.MarkovChainMonteCarloMethod"><code class="flex name class">
<span>class <span class="ident">MarkovChainMonteCarloMethod</span></span>
<span>(</span><span>rng, transitions)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic Markov chain Monte Carlo (MCMC) sampler.</p>
<p>Generates a Markov chain from some initial state by iteratively applying
a sequence of Markov transition operators.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rng</code></strong></dt>
<dd>Numpy RandomState random number generator instance.</dd>
<dt><strong><code>transitions</code></strong></dt>
<dd>Ordered dictionary of Markov chain transitions to
sequentially sample from on each chain iteration.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L41-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MarkovChainMonteCarloMethod(object):
    &#34;&#34;&#34;Generic Markov chain Monte Carlo (MCMC) sampler.

    Generates a Markov chain from some initial state by iteratively applying
    a sequence of Markov transition operators.
    &#34;&#34;&#34;

    def __init__(self, rng, transitions):
        &#34;&#34;&#34;
        Args:
            rng: Numpy RandomState random number generator instance.
            transitions: Ordered dictionary of Markov chain transitions to
                sequentially sample from on each chain iteration.
        &#34;&#34;&#34;
        self.rng = rng
        self.transitions = transitions

    def _generate_memmap_filename(self, dir_path, prefix, key, index):
        key_str = get_valid_filename(str(key))
        if index is None:
            index = 0
        return os.path.join(dir_path, f&#39;{prefix}_{index}_{key_str}.npy&#39;)

    def _open_new_memmap(self, filename, shape, dtype, default_val):
        memmap = np.lib.format.open_memmap(
            filename, dtype=dtype, mode=&#39;w+&#39;, shape=shape)
        memmap[:] = default_val
        return memmap

    def _memmaps_to_filenames(self, obj):
        if isinstance(obj, np.memmap):
            return obj.filename
        elif isinstance(obj, dict):
            return {k: self._memmaps_to_filenames(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._memmaps_to_filenames(v) for v in obj]

    def _init_chain_stats(self, n_sample, memmap_enabled, memmap_path,
                          chain_index):
        chain_stats = {}
        for trans_key, trans in self.transitions.items():
            chain_stats[trans_key] = {}
            if hasattr(trans, &#39;statistic_types&#39;):
                for key, (dtype, val) in trans.statistic_types.items():
                    if memmap_enabled:
                        filename = self._generate_memmap_filename(
                            memmap_path, &#39;stats&#39;, f&#39;{trans_key}_{key}&#39;,
                            chain_index)
                        chain_stats[trans_key][key] = self._open_new_memmap(
                            filename, (n_sample,), dtype, val)
                    else:
                        chain_stats[trans_key][key] = np.full(
                            n_sample, val, dtype)
        return chain_stats

    def _sample_chain(self, rng, n_sample, init_state, trace_funcs,
                      chain_index, parallel_chains, memmap_enabled=False,
                      memmap_path=None, monitor_stats=None):
        for trans_key, transition in self.transitions.items():
            for var_key in transition.state_variables:
                if var_key not in init_state:
                    raise ValueError(
                        f&#39;init_state does contain have {var_key} value &#39;
                        f&#39;required by {trans_key} transition.&#39;)
        if not isinstance(init_state, (ChainState, dict)):
            raise TypeError(
                &#39;init_state should be a dictionary or `ChainState`.&#39;)
        state = (ChainState(**init_state) if isinstance(init_state, dict)
                 else init_state)
        chain_stats = self._init_chain_stats(
            n_sample, memmap_enabled, memmap_path, chain_index)
        # Initialise chain trace arrays
        traces = {}
        for trace_func in trace_funcs:
            for key, val in trace_func(state).items():
                val = np.array(val) if np.isscalar(val) else val
                init = np.nan if np.issubdtype(val.dtype, np.inexact) else 0
                if memmap_enabled:
                    filename = self._generate_memmap_filename(
                        memmap_path, &#39;trace&#39;, key, chain_index)
                    traces[key] = self._open_new_memmap(
                        filename, (n_sample,) + val.shape, val.dtype, init)
                else:
                    traces[key] = np.full(
                        (n_sample,) + val.shape, init, val.dtype)
        total_return_nbytes = get_size(chain_stats) + get_size(traces)
        # Check if running in parallel and if total number of bytes to be
        # returned exceeds pickle limit
        if parallel_chains and total_return_nbytes &gt; 2**31 - 1:
            raise RuntimeError(
                f&#39;Total number of bytes allocated for arrays to be returned &#39;
                f&#39;({total_return_nbytes / 2**30:.2f} GiB) exceeds size limit &#39;
                f&#39;for returning results of a process (2 GiB). Try rerunning &#39;
                f&#39;with chain memory-mapping enabled (`memmap_enabled=True`).&#39;)
        if TQDM_AVAILABLE:
            kwargs = {
                &#39;desc&#39;: f&#39;Chain {0 if chain_index is None else chain_index}&#39;,
                &#39;unit&#39;: &#39;it&#39;,
                &#39;dynamic_ncols&#39;: True,
            }
            if parallel_chains:
                sample_range = tqdm_auto.trange(
                    n_sample, **kwargs, position=chain_index)
            else:
                sample_range = tqdm.trange(n_sample, **kwargs)
        else:
            sample_range = range(n_sample)
        try:
            for sample_index in sample_range:
                for trans_key, transition in self.transitions.items():
                    state, trans_stats = transition.sample(state, rng)
                    if trans_stats is not None:
                        if trans_key not in chain_stats:
                            logger.warning(
                                f&#39;Transition {trans_key} returned statistics &#39;
                                f&#39;but has no `statistic_types` attribute.&#39;)
                        for key, val in trans_stats.items():
                            if key in chain_stats[trans_key]:
                                chain_stats[trans_key][key][sample_index] = val
                for trace_func in trace_funcs:
                    for key, val in trace_func(state).items():
                        traces[key][sample_index] = val
                if TQDM_AVAILABLE and monitor_stats is not None:
                    postfix_stats = {}
                    for (trans_key, stats_key) in monitor_stats:
                        if (trans_key not in chain_stats or
                                stats_key not in chain_stats[trans_key]):
                            logger.warning(
                                f&#39;Statistics key pair {(trans_key, stats_key)}&#39;
                                f&#39; to be monitored is not valid.&#39;)
                        print_key = f&#39;mean({stats_key})&#39;
                        postfix_stats[print_key] = np.mean(
                            chain_stats[trans_key][stats_key][:sample_index+1])
                    sample_range.set_postfix(postfix_stats)
        except KeyboardInterrupt:
            if memmap_enabled:
                for trace in traces.values():
                    trace.flush()
                for trans_stats in chain_stats.values():
                    for stat in trans_stats.values():
                        stat.flush()
        else:
            # If not interrupted increment sample_index so that it equals
            # n_sample to flag chain completed sampling
            sample_index += 1
        if parallel_chains and memmap_enabled:
                trace_filenames = self._memmaps_to_filenames(traces)
                stats_filenames = self._memmaps_to_filenames(chain_stats)
                return trace_filenames, stats_filenames, sample_index
        return state, traces, chain_stats, sample_index

    def __preprocess_kwargs(self, kwargs):
        if &#39;memmap_enabled&#39; not in kwargs:
            kwargs[&#39;memmap_enabled&#39;] = False
        # Create temporary directory if memory mapping and no path provided
        if kwargs[&#39;memmap_enabled&#39;] and &#39;memmap_path&#39; not in kwargs:
            kwargs[&#39;memmap_path&#39;] = tempfile.mkdtemp()
        return kwargs

    def sample_chain(self, n_sample, init_state, trace_funcs, **kwargs):
        &#34;&#34;&#34;Sample a Markov chain from a given initial state.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_state (ChainState or dict): Initial chain state. Either a
                `ChainState` object or a dictionary with entries specifying
                initial values for all state variables used by chain
                transition `sample` methods.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored.

        Kwargs:
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
                key pairs, with first entry the key of a Markov transition in
                the `transitions` dict passed to the the `__init__` method and
                the second entry the key of a chain statistic that will be
                returned in the `chain_stats` dictionary. The mean over samples
                computed so far of the chain statistics associated with any
                valid key-pairs will be monitored during sampling  by printing
                as postfix to progress bar (if `tqdm` is installed).

        Returns:
            final_state (ChainState): State of chain after final iteration. May
                be used to resume sampling a chain by passing as the initial
                state to a new `sample_chain` call.
            traces (dict[str, array]): Dictionary of chain trace arrays. Values
                in dictionary are arrays of variables outputted by trace
                functions in `trace_funcs` with leading dimension of array
                corresponding to the sampling (draw) index. The key for each
                value is the corresponding key in the dictionary returned by
                the trace function which computed the traced value.
            chain_stats (dict[str, dict[str, array]]): Dictionary of chain
                transition statistic dictionaries. Values in outer dictionary
                are dictionaries of statistics for each chain transition, keyed
                by the string key for the transition. The values in each inner
                transition dictionary are arrays of chain statistic values with
                the leading dimension of each array corresponding to the
                sampling (draw) index. The key for each value is a string
                description of the corresponding integration transition
                statistic.
        &#34;&#34;&#34;
        kwargs = self.__preprocess_kwargs(kwargs)
        final_state, traces, chain_stats, sample_index = self._sample_chain(
            rng=self.rng, n_sample=n_sample, init_state=init_state,
            trace_funcs=trace_funcs, chain_index=None, parallel_chains=False,
            **kwargs)
        if sample_index != n_sample:
            # Sampling interrupted therefore truncate returned arrays
            # Using resize methods makes agnostic to whether array is
            # memory mapped or not
            for trans_stats in chain_stats.values():
                for key in trans_stats:
                    trans_stats[key].resize(
                        (sample_index,) + trans_stats[key].shape[1:])
            for key in traces:
                traces[key].resize(
                    (sample_index,) + traces[key].shape[1:])
            logger.error(
                f&#39;Sampling manually interrupted at iteration {sample_index}. &#39;
                f&#39;Arrays containing chain traces and statistics computed &#39;
                f&#39;before interruption will be returned.&#39;)
        return final_state, traces, chain_stats

    def _collate_chain_outputs(self, n_sample, chain_outputs, load_memmaps):
        final_states_stack = []
        traces_stack = {}
        n_chain = len(chain_outputs)
        chain_stats_stack = {}
        for chain_index, chain_output in enumerate(chain_outputs):
            final_state, traces, chain_stats, sample_index = chain_output
            final_states_stack.append(final_state)
            for key, val in traces.items():
                if load_memmaps:
                    val = np.lib.format.open_memmap(val)
                if sample_index != n_sample:
                    # Sampling interrupted therefore truncate returned arrays
                    # Using resize methods makes agnostic to whether array is
                    # memory mapped or not
                    val.resize((sample_index,) + val.shape[1:], refcheck=False)
                if chain_index == 0:
                    traces_stack[key] = [val]
                else:
                    traces_stack[key].append(val)
            for trans_key, trans_stats in chain_stats.items():
                if chain_index == 0:
                    chain_stats_stack[trans_key] = {}
                for key, val in trans_stats.items():
                    if load_memmaps:
                        val = np.lib.format.open_memmap(val)
                    if sample_index != n_sample:
                        # Sampling interrupted therefore truncate returned
                        # arrays Using resize methods makes agnostic to whether
                        # array is memory mapped or not
                        val.resize((sample_index,) + val.shape[1:],
                                   refcheck=False)
                    if chain_index == 0:
                        chain_stats_stack[trans_key][key] = [val]
                    else:
                        chain_stats_stack[trans_key][key].append(val)
        return final_states_stack, traces_stack, chain_stats_stack

    def sample_chains(self, n_sample, init_states, trace_funcs, n_process=1,
                      **kwargs):
        &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.
        The chains may be run in parallel across multiple independent processes
        or sequentially. In all cases all chains use independent random draws.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_states (Iterable[ChainState] or Iterable[dict]): Initial
                chain states. Each entry can be either a `ChainState` object or
                a dictionary with entries specifying initial values for all
                state variables used by chain transition `sample` methods.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored.
            n_process (int or None): Number of parallel processes to run chains
                over. If set to one then chains will be run sequentially in
                otherwise a `multiprocessing.Pool` object will be used to
                dynamically assign the chains across multiple processes. If
                set to `None` then the number of processes will default to the
                output of `os.cpu_count()`.

        Kwargs:
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
                key pairs, with first entry the key of a Markov transition in
                the `transitions` dict passed to the the `__init__` method and
                the second entry the key of a chain statistic that will be
                returned in the `chain_stats` dictionary. The mean over samples
                computed so far of the chain statistics associated with any
                valid key-pairs will be monitored during sampling  by printing
                as postfix to progress bar (if `tqdm` is installed).

        Returns:
            final_states (list[ChainState]): States of chains after final
                iteration. May be used to resume sampling a chain by passing as
                the initial states to a new `sample_chains` call.
            traces (dict[str, list[array]]): Dictionary of chain trace arrays.
                Values in dictionary are list of arrays of variables outputted
                by trace functions in `trace_funcs` with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is the corresponding key in the dictionary
                returned by the trace function which computed the traced value.
            chain_stats (dict[str, dict[str, list[array]]]): Dictionary of
                chain transition statistic dictionaries. Values in outer
                dictionary are dictionaries of statistics for each chain
                transition, keyed by the string key for the transition. The
                values in each inner transition dictionary are lists of arrays
                of chain statistic values with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is a string description of the corresponding
                integration transition statistic.
        &#34;&#34;&#34;
        n_chain = len(init_states)
        kwargs = self.__preprocess_kwargs(kwargs)
        if RANDOMGEN_AVAILABLE:
            seed = self.rng.randint(2**64, dtype=&#39;uint64&#39;)
            rngs = [randomgen.Xorshift1024(seed).jump(i).generator
                    for i in range(n_chain)]
        else:
            seeds = (self.rng.choice(2**16, n_chain, False) * 2**16 +
                     self.rng.choice(2**16, n_chain, False))
            rngs = [np.random.RandomState(seed) for seed in seeds]
        chain_outputs = []
        shared_kwargs_list = [{
                &#39;rng&#39;: rng,
                &#39;n_sample&#39;: n_sample,
                &#39;init_state&#39;: init_state,
                &#39;trace_funcs&#39;: trace_funcs,
                &#39;chain_index&#39;: c,
                **kwargs
            } for c, (rng, init_state) in enumerate(zip(rngs, init_states))]
        if n_process == 1:
            # Using single process therefore run chains sequentially
            for c, shared_kwargs in enumerate(shared_kwargs_list):
                final_state, traces, stats, sample_index = self._sample_chain(
                    **shared_kwargs, parallel_chains=False)
                chain_outputs.append(
                    (final_state, traces, stats, sample_index))
                if sample_index != n_sample:
                    logger.error(
                        f&#39;Sampling manually interrupted at chain {c} iteration&#39;
                        f&#39; {sample_index}. Arrays containing chain traces&#39;
                        f&#39; and statistics computed before interruption will&#39;
                        f&#39; be returned.&#39;)
                    break
        else:
            # Run chains in parallel using a multiprocess(ing).Pool
            # Child processes made to ignore SIGINT signals to allow handling
            # of KeyboardInterrupts in parent process
            n_completed = 0
            pool = Pool(n_process, _ignore_sigint_initialiser)
            try:
                results = [
                    pool.apply_async(
                        self._sample_chain,
                        kwds=dict(**shared_kwargs, parallel_chains=True))
                    for shared_kwargs in shared_kwargs_list]
                for result in results:
                    chain_outputs.append(result.get())
                    n_completed += 1
            except KeyboardInterrupt:
                # Close any still running processes
                pool.terminate()
                pool.join()
                err_message = &#39;Sampling manually interrupted.&#39;
                if n_completed &gt; 0:
                    err_message += (
                        f&#39; Data for {n_completed} completed chains will be &#39;
                        f&#39;returned.&#39;)
                if kwargs[&#39;memmap_enabled&#39;]:
                    err_message += (
                        f&#39; All data recorded so far including in progress &#39;
                        f&#39;chains is available in directory &#39;
                        f&#39;{kwargs[&#34;memmap_path&#34;]}.&#39;)
                logger.error(err_message)
        # When running parallel jobs with memory-mapping enabled, data arrays
        # returned by processes as file paths to array memory-maps therfore
        # load memory-maps objects from file before returing results
        load_memmaps = kwargs[&#39;memmap_enabled&#39;] and n_process &gt; 1
        return self._collate_chain_outputs(
            n_sample, chain_outputs, load_memmaps)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.samplers.MarkovChainMonteCarloMethod.sample_chain"><code class="name flex">
<span>def <span class="ident">sample_chain</span></span>(<span>self, n_sample, init_state, trace_funcs, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a Markov chain from a given initial state.</p>
<p>Performs a specified number of chain iterations (each of which may be
composed of multiple individual Markov transitions), recording the
outputs of functions of the sampled chain state after each iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_sample</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples (iterations) to draw per chain.</dd>
<dt><strong><code>init_state</code></strong> :&ensp;<code>ChainState</code> or <code>dict</code></dt>
<dd>Initial chain state. Either a
<code>ChainState</code> object or a dictionary with entries specifying
initial values for all state variables used by chain
transition <code>sample</code> methods.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>callable</code>]</dt>
<dd>List of functions which compute
the variables to be recorded at each chain iteration, with each
trace function being passed the current state and returning a
dictionary of scalar or array values corresponding to the
variable(s) to be stored. The keys in the returned dictionaries
are used to index the trace arrays in the returned traces
dictionary. If a key appears in multiple dictionaries only the
the value corresponding to the last trace function to return
that key will be stored.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>memmap_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to memory-map arrays used to store
chain data to files on disk to avoid excessive system memory
usage for long chains and/or large chain states. The chain data
is written to <code>.npy</code> files in the directory specified by
<code>memmap_path</code> (or a temporary directory if not provided). These
files persist after the termination of the function so should
be manually deleted when no longer required. Default is to
for memory mapping to be disabled.</dd>
<dt><strong><code>memmap_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory to write memory-mapped chain
data to. If not provided, a temporary directory will be created
and the chain data written to files there.</dd>
</dl>
<p>monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
key pairs, with first entry the key of a Markov transition in
the <code>transitions</code> dict passed to the the <code>__init__</code> method and
the second entry the key of a chain statistic that will be
returned in the <code>chain_stats</code> dictionary. The mean over samples
computed so far of the chain statistics associated with any
valid key-pairs will be monitored during sampling
by printing
as postfix to progress bar (if <code>tqdm</code> is installed).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>final_state</code></strong> :&ensp;<code>ChainState</code></dt>
<dd>State of chain after final iteration. May
be used to resume sampling a chain by passing as the initial
state to a new <code>sample_chain</code> call.</dd>
<dt><strong><code>traces</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>array</code>]</dt>
<dd>Dictionary of chain trace arrays. Values
in dictionary are arrays of variables outputted by trace
functions in <code>trace_funcs</code> with leading dimension of array
corresponding to the sampling (draw) index. The key for each
value is the corresponding key in the dictionary returned by
the trace function which computed the traced value.</dd>
<dt><strong><code>chain_stats</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>dict</code>[<code>str</code>, <code>array</code>]]</dt>
<dd>Dictionary of chain
transition statistic dictionaries. Values in outer dictionary
are dictionaries of statistics for each chain transition, keyed
by the string key for the transition. The values in each inner
transition dictionary are arrays of chain statistic values with
the leading dimension of each array corresponding to the
sampling (draw) index. The key for each value is a string
description of the corresponding integration transition
statistic.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L200-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_chain(self, n_sample, init_state, trace_funcs, **kwargs):
    &#34;&#34;&#34;Sample a Markov chain from a given initial state.

    Performs a specified number of chain iterations (each of which may be
    composed of multiple individual Markov transitions), recording the
    outputs of functions of the sampled chain state after each iteration.

    Args:
        n_sample (int): Number of samples (iterations) to draw per chain.
        init_state (ChainState or dict): Initial chain state. Either a
            `ChainState` object or a dictionary with entries specifying
            initial values for all state variables used by chain
            transition `sample` methods.
        trace_funcs (Iterable[callable]): List of functions which compute
            the variables to be recorded at each chain iteration, with each
            trace function being passed the current state and returning a
            dictionary of scalar or array values corresponding to the
            variable(s) to be stored. The keys in the returned dictionaries
            are used to index the trace arrays in the returned traces
            dictionary. If a key appears in multiple dictionaries only the
            the value corresponding to the last trace function to return
            that key will be stored.

    Kwargs:
        memmap_enabled (bool): Whether to memory-map arrays used to store
            chain data to files on disk to avoid excessive system memory
            usage for long chains and/or large chain states. The chain data
            is written to `.npy` files in the directory specified by
            `memmap_path` (or a temporary directory if not provided). These
            files persist after the termination of the function so should
            be manually deleted when no longer required. Default is to
            for memory mapping to be disabled.
        memmap_path (str): Path to directory to write memory-mapped chain
            data to. If not provided, a temporary directory will be created
            and the chain data written to files there.
        monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
            key pairs, with first entry the key of a Markov transition in
            the `transitions` dict passed to the the `__init__` method and
            the second entry the key of a chain statistic that will be
            returned in the `chain_stats` dictionary. The mean over samples
            computed so far of the chain statistics associated with any
            valid key-pairs will be monitored during sampling  by printing
            as postfix to progress bar (if `tqdm` is installed).

    Returns:
        final_state (ChainState): State of chain after final iteration. May
            be used to resume sampling a chain by passing as the initial
            state to a new `sample_chain` call.
        traces (dict[str, array]): Dictionary of chain trace arrays. Values
            in dictionary are arrays of variables outputted by trace
            functions in `trace_funcs` with leading dimension of array
            corresponding to the sampling (draw) index. The key for each
            value is the corresponding key in the dictionary returned by
            the trace function which computed the traced value.
        chain_stats (dict[str, dict[str, array]]): Dictionary of chain
            transition statistic dictionaries. Values in outer dictionary
            are dictionaries of statistics for each chain transition, keyed
            by the string key for the transition. The values in each inner
            transition dictionary are arrays of chain statistic values with
            the leading dimension of each array corresponding to the
            sampling (draw) index. The key for each value is a string
            description of the corresponding integration transition
            statistic.
    &#34;&#34;&#34;
    kwargs = self.__preprocess_kwargs(kwargs)
    final_state, traces, chain_stats, sample_index = self._sample_chain(
        rng=self.rng, n_sample=n_sample, init_state=init_state,
        trace_funcs=trace_funcs, chain_index=None, parallel_chains=False,
        **kwargs)
    if sample_index != n_sample:
        # Sampling interrupted therefore truncate returned arrays
        # Using resize methods makes agnostic to whether array is
        # memory mapped or not
        for trans_stats in chain_stats.values():
            for key in trans_stats:
                trans_stats[key].resize(
                    (sample_index,) + trans_stats[key].shape[1:])
        for key in traces:
            traces[key].resize(
                (sample_index,) + traces[key].shape[1:])
        logger.error(
            f&#39;Sampling manually interrupted at iteration {sample_index}. &#39;
            f&#39;Arrays containing chain traces and statistics computed &#39;
            f&#39;before interruption will be returned.&#39;)
    return final_state, traces, chain_stats</code></pre>
</details>
</dd>
<dt id="mici.samplers.MarkovChainMonteCarloMethod.sample_chains"><code class="name flex">
<span>def <span class="ident">sample_chains</span></span>(<span>self, n_sample, init_states, trace_funcs, n_process=1, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample one or more Markov chains from given initial states.</p>
<p>Performs a specified number of chain iterations (each of which may be
composed of multiple individual Markov transitions), recording the
outputs of functions of the sampled chain state after each iteration.
The chains may be run in parallel across multiple independent processes
or sequentially. In all cases all chains use independent random draws.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_sample</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples (iterations) to draw per chain.</dd>
<dt><strong><code>init_states</code></strong> :&ensp;<code>Iterable</code>[<code>ChainState</code>] or <code>Iterable</code>[<code>dict</code>]</dt>
<dd>Initial
chain states. Each entry can be either a <code>ChainState</code> object or
a dictionary with entries specifying initial values for all
state variables used by chain transition <code>sample</code> methods.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>callable</code>]</dt>
<dd>List of functions which compute
the variables to be recorded at each chain iteration, with each
trace function being passed the current state and returning a
dictionary of scalar or array values corresponding to the
variable(s) to be stored. The keys in the returned dictionaries
are used to index the trace arrays in the returned traces
dictionary. If a key appears in multiple dictionaries only the
the value corresponding to the last trace function to return
that key will be stored.</dd>
<dt><strong><code>n_process</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Number of parallel processes to run chains
over. If set to one then chains will be run sequentially in
otherwise a <code>multiprocessing.Pool</code> object will be used to
dynamically assign the chains across multiple processes. If
set to <code>None</code> then the number of processes will default to the
output of <code>os.cpu_count()</code>.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>memmap_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to memory-map arrays used to store
chain data to files on disk to avoid excessive system memory
usage for long chains and/or large chain states. The chain data
is written to <code>.npy</code> files in the directory specified by
<code>memmap_path</code> (or a temporary directory if not provided). These
files persist after the termination of the function so should
be manually deleted when no longer required. Default is to
for memory mapping to be disabled.</dd>
<dt><strong><code>memmap_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory to write memory-mapped chain
data to. If not provided, a temporary directory will be created
and the chain data written to files there.</dd>
</dl>
<p>monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
key pairs, with first entry the key of a Markov transition in
the <code>transitions</code> dict passed to the the <code>__init__</code> method and
the second entry the key of a chain statistic that will be
returned in the <code>chain_stats</code> dictionary. The mean over samples
computed so far of the chain statistics associated with any
valid key-pairs will be monitored during sampling
by printing
as postfix to progress bar (if <code>tqdm</code> is installed).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>final_states</code></strong> :&ensp;<code>list</code>[<code>ChainState</code>]</dt>
<dd>States of chains after final
iteration. May be used to resume sampling a chain by passing as
the initial states to a new <code>sample_chains</code> call.</dd>
<dt><strong><code>traces</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>list</code>[<code>array</code>]]</dt>
<dd>Dictionary of chain trace arrays.
Values in dictionary are list of arrays of variables outputted
by trace functions in <code>trace_funcs</code> with each array in the list
corresponding to a single chain and the leading dimension of
each array corresponding to the sampling (draw) index. The key
for each value is the corresponding key in the dictionary
returned by the trace function which computed the traced value.</dd>
<dt><strong><code>chain_stats</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>dict</code>[<code>str</code>, <code>list</code>[<code>array</code>]]]</dt>
<dd>Dictionary of
chain transition statistic dictionaries. Values in outer
dictionary are dictionaries of statistics for each chain
transition, keyed by the string key for the transition. The
values in each inner transition dictionary are lists of arrays
of chain statistic values with each array in the list
corresponding to a single chain and the leading dimension of
each array corresponding to the sampling (draw) index. The key
for each value is a string description of the corresponding
integration transition statistic.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L324-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_chains(self, n_sample, init_states, trace_funcs, n_process=1,
                  **kwargs):
    &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

    Performs a specified number of chain iterations (each of which may be
    composed of multiple individual Markov transitions), recording the
    outputs of functions of the sampled chain state after each iteration.
    The chains may be run in parallel across multiple independent processes
    or sequentially. In all cases all chains use independent random draws.

    Args:
        n_sample (int): Number of samples (iterations) to draw per chain.
        init_states (Iterable[ChainState] or Iterable[dict]): Initial
            chain states. Each entry can be either a `ChainState` object or
            a dictionary with entries specifying initial values for all
            state variables used by chain transition `sample` methods.
        trace_funcs (Iterable[callable]): List of functions which compute
            the variables to be recorded at each chain iteration, with each
            trace function being passed the current state and returning a
            dictionary of scalar or array values corresponding to the
            variable(s) to be stored. The keys in the returned dictionaries
            are used to index the trace arrays in the returned traces
            dictionary. If a key appears in multiple dictionaries only the
            the value corresponding to the last trace function to return
            that key will be stored.
        n_process (int or None): Number of parallel processes to run chains
            over. If set to one then chains will be run sequentially in
            otherwise a `multiprocessing.Pool` object will be used to
            dynamically assign the chains across multiple processes. If
            set to `None` then the number of processes will default to the
            output of `os.cpu_count()`.

    Kwargs:
        memmap_enabled (bool): Whether to memory-map arrays used to store
            chain data to files on disk to avoid excessive system memory
            usage for long chains and/or large chain states. The chain data
            is written to `.npy` files in the directory specified by
            `memmap_path` (or a temporary directory if not provided). These
            files persist after the termination of the function so should
            be manually deleted when no longer required. Default is to
            for memory mapping to be disabled.
        memmap_path (str): Path to directory to write memory-mapped chain
            data to. If not provided, a temporary directory will be created
            and the chain data written to files there.
        monitor_stats (Iterable[tuple(str, str)]): List of tuples of string
            key pairs, with first entry the key of a Markov transition in
            the `transitions` dict passed to the the `__init__` method and
            the second entry the key of a chain statistic that will be
            returned in the `chain_stats` dictionary. The mean over samples
            computed so far of the chain statistics associated with any
            valid key-pairs will be monitored during sampling  by printing
            as postfix to progress bar (if `tqdm` is installed).

    Returns:
        final_states (list[ChainState]): States of chains after final
            iteration. May be used to resume sampling a chain by passing as
            the initial states to a new `sample_chains` call.
        traces (dict[str, list[array]]): Dictionary of chain trace arrays.
            Values in dictionary are list of arrays of variables outputted
            by trace functions in `trace_funcs` with each array in the list
            corresponding to a single chain and the leading dimension of
            each array corresponding to the sampling (draw) index. The key
            for each value is the corresponding key in the dictionary
            returned by the trace function which computed the traced value.
        chain_stats (dict[str, dict[str, list[array]]]): Dictionary of
            chain transition statistic dictionaries. Values in outer
            dictionary are dictionaries of statistics for each chain
            transition, keyed by the string key for the transition. The
            values in each inner transition dictionary are lists of arrays
            of chain statistic values with each array in the list
            corresponding to a single chain and the leading dimension of
            each array corresponding to the sampling (draw) index. The key
            for each value is a string description of the corresponding
            integration transition statistic.
    &#34;&#34;&#34;
    n_chain = len(init_states)
    kwargs = self.__preprocess_kwargs(kwargs)
    if RANDOMGEN_AVAILABLE:
        seed = self.rng.randint(2**64, dtype=&#39;uint64&#39;)
        rngs = [randomgen.Xorshift1024(seed).jump(i).generator
                for i in range(n_chain)]
    else:
        seeds = (self.rng.choice(2**16, n_chain, False) * 2**16 +
                 self.rng.choice(2**16, n_chain, False))
        rngs = [np.random.RandomState(seed) for seed in seeds]
    chain_outputs = []
    shared_kwargs_list = [{
            &#39;rng&#39;: rng,
            &#39;n_sample&#39;: n_sample,
            &#39;init_state&#39;: init_state,
            &#39;trace_funcs&#39;: trace_funcs,
            &#39;chain_index&#39;: c,
            **kwargs
        } for c, (rng, init_state) in enumerate(zip(rngs, init_states))]
    if n_process == 1:
        # Using single process therefore run chains sequentially
        for c, shared_kwargs in enumerate(shared_kwargs_list):
            final_state, traces, stats, sample_index = self._sample_chain(
                **shared_kwargs, parallel_chains=False)
            chain_outputs.append(
                (final_state, traces, stats, sample_index))
            if sample_index != n_sample:
                logger.error(
                    f&#39;Sampling manually interrupted at chain {c} iteration&#39;
                    f&#39; {sample_index}. Arrays containing chain traces&#39;
                    f&#39; and statistics computed before interruption will&#39;
                    f&#39; be returned.&#39;)
                break
    else:
        # Run chains in parallel using a multiprocess(ing).Pool
        # Child processes made to ignore SIGINT signals to allow handling
        # of KeyboardInterrupts in parent process
        n_completed = 0
        pool = Pool(n_process, _ignore_sigint_initialiser)
        try:
            results = [
                pool.apply_async(
                    self._sample_chain,
                    kwds=dict(**shared_kwargs, parallel_chains=True))
                for shared_kwargs in shared_kwargs_list]
            for result in results:
                chain_outputs.append(result.get())
                n_completed += 1
        except KeyboardInterrupt:
            # Close any still running processes
            pool.terminate()
            pool.join()
            err_message = &#39;Sampling manually interrupted.&#39;
            if n_completed &gt; 0:
                err_message += (
                    f&#39; Data for {n_completed} completed chains will be &#39;
                    f&#39;returned.&#39;)
            if kwargs[&#39;memmap_enabled&#39;]:
                err_message += (
                    f&#39; All data recorded so far including in progress &#39;
                    f&#39;chains is available in directory &#39;
                    f&#39;{kwargs[&#34;memmap_path&#34;]}.&#39;)
            logger.error(err_message)
    # When running parallel jobs with memory-mapping enabled, data arrays
    # returned by processes as file paths to array memory-maps therfore
    # load memory-maps objects from file before returing results
    load_memmaps = kwargs[&#39;memmap_enabled&#39;] and n_process &gt; 1
    return self._collate_chain_outputs(
        n_sample, chain_outputs, load_memmaps)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.samplers.HamiltonianMCMC"><code class="flex name class">
<span>class <span class="ident">HamiltonianMCMC</span></span>
<span>(</span><span>system, rng, integration_transition, momentum_transition=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper class for Hamiltonian Markov chain Monte Carlo (H-MCMC) methods.</p>
<p>Here H-MCMC is defined as a MCMC method which augments the original target
variable (henceforth position variable) with a momentum variable with a
user specified conditional distribution given the position variable. In
each chain iteration two Markov transitions leaving the resulting joint
distribution on position and momentum variables invariant are applied -
the momentum variables are updated in a transition which leaves their
conditional distribution invariant (momentum transition) and then a
trajectory in the joint space is generated by numerically integrating a
Hamiltonian dynamic with an appropriate symplectic integrator which is
exactly reversible, volume preserving and approximately conserves the joint
probability density of the target-momentum state pair; one state from the
resulting trajectory is then selected as the next joint chain state using
an appropriate sampling scheme such that the joint distribution is left
exactly invariant (integration transition).</p>
<p>There are various options available for both the momentum transition and
integration transition, with by default the momentum transition set to be
independent resampling of the momentum variables from their conditional
distribution.</p>
<h2 id="references">References</h2>
<ol>
<li>Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.</li>
<li>Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
Handbook of Markov Chain Monte Carlo, 2(11), p.2.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>rng</code></strong></dt>
<dd>Numpy RandomState random number generator instance.</dd>
<dt><strong><code>integration_transition</code></strong></dt>
<dd>Markov transition operator which jointly
updates the position and momentum components of the chain
state by integrating the Hamiltonian dynamics of the system
to propose new values for the state.</dd>
<dt><strong><code>momentum_transition</code></strong></dt>
<dd>Markov transition operator which updates only
the momentum component of the chain state. If set to <code>None</code> a
transition operator which independently samples the momentum
from its conditional distribution will be used.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L470-L696" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HamiltonianMCMC(MarkovChainMonteCarloMethod):
    &#34;&#34;&#34;Wrapper class for Hamiltonian Markov chain Monte Carlo (H-MCMC) methods.

    Here H-MCMC is defined as a MCMC method which augments the original target
    variable (henceforth position variable) with a momentum variable with a
    user specified conditional distribution given the position variable. In
    each chain iteration two Markov transitions leaving the resulting joint
    distribution on position and momentum variables invariant are applied -
    the momentum variables are updated in a transition which leaves their
    conditional distribution invariant (momentum transition) and then a
    trajectory in the joint space is generated by numerically integrating a
    Hamiltonian dynamic with an appropriate symplectic integrator which is
    exactly reversible, volume preserving and approximately conserves the joint
    probability density of the target-momentum state pair; one state from the
    resulting trajectory is then selected as the next joint chain state using
    an appropriate sampling scheme such that the joint distribution is left
    exactly invariant (integration transition).

    There are various options available for both the momentum transition and
    integration transition, with by default the momentum transition set to be
    independent resampling of the momentum variables from their conditional
    distribution.

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, rng, integration_transition,
                 momentum_transition=None):
        &#34;&#34;&#34;
        Args:
            system: Hamiltonian system to be simulated.
            rng: Numpy RandomState random number generator instance.
            integration_transition: Markov transition operator which jointly
                updates the position and momentum components of the chain
                state by integrating the Hamiltonian dynamics of the system
                to propose new values for the state.
            momentum_transition: Markov transition operator which updates only
                the momentum component of the chain state. If set to `None` a
                transition operator which independently samples the momentum
                from its conditional distribution will be used.
        &#34;&#34;&#34;
        self.system = system
        self.rng = rng
        if momentum_transition is None:
            momentum_transition = trans.IndependentMomentumTransition(system)
        super().__init__(rng, OrderedDict(
            momentum_transition=momentum_transition,
            integration_transition=integration_transition))

    def _preprocess_init_state(self, init_state):
        &#34;&#34;&#34;Make sure initial state is a ChainState and has momentum.&#34;&#34;&#34;
        if isinstance(init_state, np.ndarray):
            # If array use to set position component of new ChainState
            init_state = ChainState(pos=init_state, mom=None, dir=1)
        elif not isinstance(init_state, ChainState) or &#39;mom&#39; not in init_state:
            raise TypeError(
                &#39;init_state should be an array or `ChainState` with &#39;
                &#39;`mom` attribute.&#39;)
        if init_state.mom is None:
            init_state.mom = self.system.sample_momentum(init_state, self.rng)
        return init_state

    def __preprocess_kwargs(self, kwargs):
        # default to tracing only position component of state
        if &#39;trace_funcs&#39; not in kwargs:
            kwargs[&#39;trace_funcs&#39;] = [lambda state: {&#39;pos&#39;: state.pos}]
        # if `monitor_stats` specified, expand all statistics keys to key pairs
        # with transition key set to `integration_transition`
        if &#39;monitor_stats&#39; in kwargs:
            kwargs[&#39;monitor_stats&#39;] = [
                (&#39;integration_transition&#39;, stats_key)
                for stats_key in kwargs[&#39;monitor_stats&#39;]]
        else:
            kwargs[&#39;monitor_stats&#39;] = [
                (&#39;integration_transition&#39;, &#39;accept_prob&#39;)]
        return kwargs

    def sample_chain(self, n_sample, init_state, **kwargs):
        &#34;&#34;&#34;Sample a Markov chain from a given initial state.

        Performs a specified number of chain iterations (each of which may be
        composed of multiple individual Markov transitions), recording the
        outputs of functions of the sampled chain state after each iteration.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_state (ChainState or array): Initial chain state. The state
                can be either an array specifying the state position component
                or a `ChainState` instance. If an array is passed or the `mom`
                attribute of the state is not set, a momentum component will be
                independently sampled from its conditional distribution.

        Kwargs:
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored. Default is for a single trace function
                which records the `pos` component of the state.
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[str]): List of string keys of chain
                statistics to monitor mean of over samples computed so far
                during sampling by printing as postfix to progress bar (if
                `tqdm` is installed). Default is to print only the mean
                `accept_prob` statistic.

        Returns:
            final_state (ChainState): State of chain after final iteration. May
                be used to resume sampling a chain by passing as the initial
                state to a new `sample_chain` call.
            traces (dict[str, array]): Dictionary of chain trace arrays. Values
                in dictionary are arrays of variables outputted by trace
                functions in `trace_funcs` with leading dimension of array
                corresponding to the sampling (draw) index. The key for each
                value is the corresponding key in the dictionary returned by
                the trace function which computed the traced value.
            chain_stats (dict[str, array]): Dictionary of chain integration
                transition statistics. Values in dictionary are arrays of chain
                statistic values with the leading dimension of each array
                corresponding to the sampling (draw) index. The key for each
                value is a string description of the corresponding integration
                transition statistic.
        &#34;&#34;&#34;
        init_state = self._preprocess_init_state(init_state)
        kwargs = self.__preprocess_kwargs(kwargs)
        final_state, traces, chain_stats = super().sample_chain(
            n_sample, init_state, **kwargs)
        chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
        return final_state, traces, chain_stats

    def sample_chains(self, n_sample, init_states, **kwargs):
        &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

        Performs a specified number of chain iterations (each of consists of a
        momentum transition and integration transition), recording the outputs
        of functions of the sampled chain state after each iteration. The
        chains may be run in parallel across multiple independent processes or
        sequentially. In all cases all chains use independent random draws.

        Args:
            n_sample (int): Number of samples (iterations) to draw per chain.
            init_states (Iterable[ChainState] or Iterable[array]): Initial
                chain states. Each state can be either an array specifying the
                state position component or a `ChainState` instance. If an
                array is passed or the `mom` attribute of the state is not set,
                a momentum component will be independently sampled from its
                conditional distribution. One chain will be run for each state
                in the iterable sequence.

        Kwargs:
            n_process (int or None): Number of parallel processes to run chains
                over. If set to one then chains will be run sequentially in
                otherwise a `multiprocessing.Pool` object will be used to
                dynamically assign the chains across multiple processes. If set
                to `None` then the number of processes will be set to the
                output of `os.cpu_count()`. Default is `n_process=1`.
            trace_funcs (Iterable[callable]): List of functions which compute
                the variables to be recorded at each chain iteration, with each
                trace function being passed the current state and returning a
                dictionary of scalar or array values corresponding to the
                variable(s) to be stored. The keys in the returned dictionaries
                are used to index the trace arrays in the returned traces
                dictionary. If a key appears in multiple dictionaries only the
                the value corresponding to the last trace function to return
                that key will be stored. Default is for a single trace function
                which records the `pos` component of the state.
            memmap_enabled (bool): Whether to memory-map arrays used to store
                chain data to files on disk to avoid excessive system memory
                usage for long chains and/or large chain states. The chain data
                is written to `.npy` files in the directory specified by
                `memmap_path` (or a temporary directory if not provided). These
                files persist after the termination of the function so should
                be manually deleted when no longer required. Default is to
                for memory mapping to be disabled.
            memmap_path (str): Path to directory to write memory-mapped chain
                data to. If not provided, a temporary directory will be created
                and the chain data written to files there.
            monitor_stats (Iterable[str]): List of string keys of chain
                statistics to monitor mean of over samples computed so far
                during sampling by printing as postfix to progress bar (if
                `tqdm` is installed). Default is to print only the mean
                `accept_prob` statistic.

        Returns:
            final_states (list[ChainState]): States of chains after final
                iteration. May be used to resume sampling a chain by passing as
                the initial states to a new `sample_chains` call.
            traces (dict[str, list[array]]): Dictionary of chain trace arrays.
                Values in dictionary are list of arrays of variables outputted
                by trace functions in `trace_funcs` with each array in the list
                corresponding to a single chain and the leading dimension of
                each array corresponding to the sampling (draw) index. The key
                for each value is the corresponding key in the dictionary
                returned by the trace function which computed the traced value.
            chain_stats (dict[str, list[array]]): Dictionary of chain
                integration transition statistics. Values in dictionary are
                lists of arrays of chain statistic values with each array in
                the list corresponding to a single chain and the leading
                dimension of each array corresponding to the sampling (draw)
                index. The key for each value is a string description of the
                corresponding integration transition statistic.
        &#34;&#34;&#34;
        init_states = [self._preprocess_init_state(i) for i in init_states]
        kwargs = self.__preprocess_kwargs(kwargs)
        final_states, traces, chain_stats = super().sample_chains(
            n_sample, init_states, **kwargs)
        chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
        return final_states, traces, chain_stats</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.samplers.MarkovChainMonteCarloMethod" href="#mici.samplers.MarkovChainMonteCarloMethod">MarkovChainMonteCarloMethod</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mici.samplers.StaticMetropolisHMC" href="#mici.samplers.StaticMetropolisHMC">StaticMetropolisHMC</a></li>
<li><a title="mici.samplers.RandomMetropolisHMC" href="#mici.samplers.RandomMetropolisHMC">RandomMetropolisHMC</a></li>
<li><a title="mici.samplers.DynamicMultinomialHMC" href="#mici.samplers.DynamicMultinomialHMC">DynamicMultinomialHMC</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mici.samplers.HamiltonianMCMC.sample_chain"><code class="name flex">
<span>def <span class="ident">sample_chain</span></span>(<span>self, n_sample, init_state, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample a Markov chain from a given initial state.</p>
<p>Performs a specified number of chain iterations (each of which may be
composed of multiple individual Markov transitions), recording the
outputs of functions of the sampled chain state after each iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_sample</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples (iterations) to draw per chain.</dd>
<dt><strong><code>init_state</code></strong> :&ensp;<code>ChainState</code> or <code>array</code></dt>
<dd>Initial chain state. The state
can be either an array specifying the state position component
or a <code>ChainState</code> instance. If an array is passed or the <code>mom</code>
attribute of the state is not set, a momentum component will be
independently sampled from its conditional distribution.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>callable</code>]</dt>
<dd>List of functions which compute
the variables to be recorded at each chain iteration, with each
trace function being passed the current state and returning a
dictionary of scalar or array values corresponding to the
variable(s) to be stored. The keys in the returned dictionaries
are used to index the trace arrays in the returned traces
dictionary. If a key appears in multiple dictionaries only the
the value corresponding to the last trace function to return
that key will be stored. Default is for a single trace function
which records the <code>pos</code> component of the state.</dd>
<dt><strong><code>memmap_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to memory-map arrays used to store
chain data to files on disk to avoid excessive system memory
usage for long chains and/or large chain states. The chain data
is written to <code>.npy</code> files in the directory specified by
<code>memmap_path</code> (or a temporary directory if not provided). These
files persist after the termination of the function so should
be manually deleted when no longer required. Default is to
for memory mapping to be disabled.</dd>
<dt><strong><code>memmap_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory to write memory-mapped chain
data to. If not provided, a temporary directory will be created
and the chain data written to files there.</dd>
<dt><strong><code>monitor_stats</code></strong> :&ensp;<code>Iterable</code>[<code>str</code>]</dt>
<dd>List of string keys of chain
statistics to monitor mean of over samples computed so far
during sampling by printing as postfix to progress bar (if
<code>tqdm</code> is installed). Default is to print only the mean
<code>accept_prob</code> statistic.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>final_state</code></strong> :&ensp;<code>ChainState</code></dt>
<dd>State of chain after final iteration. May
be used to resume sampling a chain by passing as the initial
state to a new <code>sample_chain</code> call.</dd>
<dt><strong><code>traces</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>array</code>]</dt>
<dd>Dictionary of chain trace arrays. Values
in dictionary are arrays of variables outputted by trace
functions in <code>trace_funcs</code> with leading dimension of array
corresponding to the sampling (draw) index. The key for each
value is the corresponding key in the dictionary returned by
the trace function which computed the traced value.</dd>
<dt><strong><code>chain_stats</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>array</code>]</dt>
<dd>Dictionary of chain integration
transition statistics. Values in dictionary are arrays of chain
statistic values with the leading dimension of each array
corresponding to the sampling (draw) index. The key for each
value is a string description of the corresponding integration
transition statistic.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L552-L617" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_chain(self, n_sample, init_state, **kwargs):
    &#34;&#34;&#34;Sample a Markov chain from a given initial state.

    Performs a specified number of chain iterations (each of which may be
    composed of multiple individual Markov transitions), recording the
    outputs of functions of the sampled chain state after each iteration.

    Args:
        n_sample (int): Number of samples (iterations) to draw per chain.
        init_state (ChainState or array): Initial chain state. The state
            can be either an array specifying the state position component
            or a `ChainState` instance. If an array is passed or the `mom`
            attribute of the state is not set, a momentum component will be
            independently sampled from its conditional distribution.

    Kwargs:
        trace_funcs (Iterable[callable]): List of functions which compute
            the variables to be recorded at each chain iteration, with each
            trace function being passed the current state and returning a
            dictionary of scalar or array values corresponding to the
            variable(s) to be stored. The keys in the returned dictionaries
            are used to index the trace arrays in the returned traces
            dictionary. If a key appears in multiple dictionaries only the
            the value corresponding to the last trace function to return
            that key will be stored. Default is for a single trace function
            which records the `pos` component of the state.
        memmap_enabled (bool): Whether to memory-map arrays used to store
            chain data to files on disk to avoid excessive system memory
            usage for long chains and/or large chain states. The chain data
            is written to `.npy` files in the directory specified by
            `memmap_path` (or a temporary directory if not provided). These
            files persist after the termination of the function so should
            be manually deleted when no longer required. Default is to
            for memory mapping to be disabled.
        memmap_path (str): Path to directory to write memory-mapped chain
            data to. If not provided, a temporary directory will be created
            and the chain data written to files there.
        monitor_stats (Iterable[str]): List of string keys of chain
            statistics to monitor mean of over samples computed so far
            during sampling by printing as postfix to progress bar (if
            `tqdm` is installed). Default is to print only the mean
            `accept_prob` statistic.

    Returns:
        final_state (ChainState): State of chain after final iteration. May
            be used to resume sampling a chain by passing as the initial
            state to a new `sample_chain` call.
        traces (dict[str, array]): Dictionary of chain trace arrays. Values
            in dictionary are arrays of variables outputted by trace
            functions in `trace_funcs` with leading dimension of array
            corresponding to the sampling (draw) index. The key for each
            value is the corresponding key in the dictionary returned by
            the trace function which computed the traced value.
        chain_stats (dict[str, array]): Dictionary of chain integration
            transition statistics. Values in dictionary are arrays of chain
            statistic values with the leading dimension of each array
            corresponding to the sampling (draw) index. The key for each
            value is a string description of the corresponding integration
            transition statistic.
    &#34;&#34;&#34;
    init_state = self._preprocess_init_state(init_state)
    kwargs = self.__preprocess_kwargs(kwargs)
    final_state, traces, chain_stats = super().sample_chain(
        n_sample, init_state, **kwargs)
    chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
    return final_state, traces, chain_stats</code></pre>
</details>
</dd>
<dt id="mici.samplers.HamiltonianMCMC.sample_chains"><code class="name flex">
<span>def <span class="ident">sample_chains</span></span>(<span>self, n_sample, init_states, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sample one or more Markov chains from given initial states.</p>
<p>Performs a specified number of chain iterations (each of consists of a
momentum transition and integration transition), recording the outputs
of functions of the sampled chain state after each iteration. The
chains may be run in parallel across multiple independent processes or
sequentially. In all cases all chains use independent random draws.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_sample</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples (iterations) to draw per chain.</dd>
<dt><strong><code>init_states</code></strong> :&ensp;<code>Iterable</code>[<code>ChainState</code>] or <code>Iterable</code>[<code>array</code>]</dt>
<dd>Initial
chain states. Each state can be either an array specifying the
state position component or a <code>ChainState</code> instance. If an
array is passed or the <code>mom</code> attribute of the state is not set,
a momentum component will be independently sampled from its
conditional distribution. One chain will be run for each state
in the iterable sequence.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>n_process</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Number of parallel processes to run chains
over. If set to one then chains will be run sequentially in
otherwise a <code>multiprocessing.Pool</code> object will be used to
dynamically assign the chains across multiple processes. If set
to <code>None</code> then the number of processes will be set to the
output of <code>os.cpu_count()</code>. Default is <code>n_process=1</code>.</dd>
<dt><strong><code>trace_funcs</code></strong> :&ensp;<code>Iterable</code>[<code>callable</code>]</dt>
<dd>List of functions which compute
the variables to be recorded at each chain iteration, with each
trace function being passed the current state and returning a
dictionary of scalar or array values corresponding to the
variable(s) to be stored. The keys in the returned dictionaries
are used to index the trace arrays in the returned traces
dictionary. If a key appears in multiple dictionaries only the
the value corresponding to the last trace function to return
that key will be stored. Default is for a single trace function
which records the <code>pos</code> component of the state.</dd>
<dt><strong><code>memmap_enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to memory-map arrays used to store
chain data to files on disk to avoid excessive system memory
usage for long chains and/or large chain states. The chain data
is written to <code>.npy</code> files in the directory specified by
<code>memmap_path</code> (or a temporary directory if not provided). These
files persist after the termination of the function so should
be manually deleted when no longer required. Default is to
for memory mapping to be disabled.</dd>
<dt><strong><code>memmap_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory to write memory-mapped chain
data to. If not provided, a temporary directory will be created
and the chain data written to files there.</dd>
<dt><strong><code>monitor_stats</code></strong> :&ensp;<code>Iterable</code>[<code>str</code>]</dt>
<dd>List of string keys of chain
statistics to monitor mean of over samples computed so far
during sampling by printing as postfix to progress bar (if
<code>tqdm</code> is installed). Default is to print only the mean
<code>accept_prob</code> statistic.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>final_states</code></strong> :&ensp;<code>list</code>[<code>ChainState</code>]</dt>
<dd>States of chains after final
iteration. May be used to resume sampling a chain by passing as
the initial states to a new <code>sample_chains</code> call.</dd>
<dt><strong><code>traces</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>list</code>[<code>array</code>]]</dt>
<dd>Dictionary of chain trace arrays.
Values in dictionary are list of arrays of variables outputted
by trace functions in <code>trace_funcs</code> with each array in the list
corresponding to a single chain and the leading dimension of
each array corresponding to the sampling (draw) index. The key
for each value is the corresponding key in the dictionary
returned by the trace function which computed the traced value.</dd>
<dt><strong><code>chain_stats</code></strong> :&ensp;<code>dict</code>[<code>str</code>, <code>list</code>[<code>array</code>]]</dt>
<dd>Dictionary of chain
integration transition statistics. Values in dictionary are
lists of arrays of chain statistic values with each array in
the list corresponding to a single chain and the leading
dimension of each array corresponding to the sampling (draw)
index. The key for each value is a string description of the
corresponding integration transition statistic.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L619-L696" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample_chains(self, n_sample, init_states, **kwargs):
    &#34;&#34;&#34;Sample one or more Markov chains from given initial states.

    Performs a specified number of chain iterations (each of consists of a
    momentum transition and integration transition), recording the outputs
    of functions of the sampled chain state after each iteration. The
    chains may be run in parallel across multiple independent processes or
    sequentially. In all cases all chains use independent random draws.

    Args:
        n_sample (int): Number of samples (iterations) to draw per chain.
        init_states (Iterable[ChainState] or Iterable[array]): Initial
            chain states. Each state can be either an array specifying the
            state position component or a `ChainState` instance. If an
            array is passed or the `mom` attribute of the state is not set,
            a momentum component will be independently sampled from its
            conditional distribution. One chain will be run for each state
            in the iterable sequence.

    Kwargs:
        n_process (int or None): Number of parallel processes to run chains
            over. If set to one then chains will be run sequentially in
            otherwise a `multiprocessing.Pool` object will be used to
            dynamically assign the chains across multiple processes. If set
            to `None` then the number of processes will be set to the
            output of `os.cpu_count()`. Default is `n_process=1`.
        trace_funcs (Iterable[callable]): List of functions which compute
            the variables to be recorded at each chain iteration, with each
            trace function being passed the current state and returning a
            dictionary of scalar or array values corresponding to the
            variable(s) to be stored. The keys in the returned dictionaries
            are used to index the trace arrays in the returned traces
            dictionary. If a key appears in multiple dictionaries only the
            the value corresponding to the last trace function to return
            that key will be stored. Default is for a single trace function
            which records the `pos` component of the state.
        memmap_enabled (bool): Whether to memory-map arrays used to store
            chain data to files on disk to avoid excessive system memory
            usage for long chains and/or large chain states. The chain data
            is written to `.npy` files in the directory specified by
            `memmap_path` (or a temporary directory if not provided). These
            files persist after the termination of the function so should
            be manually deleted when no longer required. Default is to
            for memory mapping to be disabled.
        memmap_path (str): Path to directory to write memory-mapped chain
            data to. If not provided, a temporary directory will be created
            and the chain data written to files there.
        monitor_stats (Iterable[str]): List of string keys of chain
            statistics to monitor mean of over samples computed so far
            during sampling by printing as postfix to progress bar (if
            `tqdm` is installed). Default is to print only the mean
            `accept_prob` statistic.

    Returns:
        final_states (list[ChainState]): States of chains after final
            iteration. May be used to resume sampling a chain by passing as
            the initial states to a new `sample_chains` call.
        traces (dict[str, list[array]]): Dictionary of chain trace arrays.
            Values in dictionary are list of arrays of variables outputted
            by trace functions in `trace_funcs` with each array in the list
            corresponding to a single chain and the leading dimension of
            each array corresponding to the sampling (draw) index. The key
            for each value is the corresponding key in the dictionary
            returned by the trace function which computed the traced value.
        chain_stats (dict[str, list[array]]): Dictionary of chain
            integration transition statistics. Values in dictionary are
            lists of arrays of chain statistic values with each array in
            the list corresponding to a single chain and the leading
            dimension of each array corresponding to the sampling (draw)
            index. The key for each value is a string description of the
            corresponding integration transition statistic.
    &#34;&#34;&#34;
    init_states = [self._preprocess_init_state(i) for i in init_states]
    kwargs = self.__preprocess_kwargs(kwargs)
    final_states, traces, chain_stats = super().sample_chains(
        n_sample, init_states, **kwargs)
    chain_stats = chain_stats.get(&#39;integration_transition&#39;, {})
    return final_states, traces, chain_stats</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mici.samplers.StaticMetropolisHMC"><code class="flex name class">
<span>class <span class="ident">StaticMetropolisHMC</span></span>
<span>(</span><span>system, integrator, rng, n_step, momentum_transition=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Static integration time H-MCMC implementation with Metropolis sampling.</p>
<p>In each transition a trajectory is generated by integrating the Hamiltonian
dynamics from the current state in the current integration time direction
for a fixed integer number of integrator steps.</p>
<p>The state at the end of the trajectory with the integration direction
negated (this ensuring the proposed move is an involution) is used as the
proposal in a Metropolis acceptance step. The integration direction is then
deterministically negated again irrespective of the accept decision, with
the effect being that on acceptance the integration direction will be equal
to its initial value and on rejection the integration direction will be
the negation of its initial value.</p>
<p>This is original proposed Hybrid Monte Carlo (often now instead termed
Hamiltonian Monte Carlo) algorithm [1,2].</p>
<h2 id="references">References</h2>
<ol>
<li>Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.</li>
<li>Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
Handbook of Markov Chain Monte Carlo, 2(11), p.2.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>rng</code></strong></dt>
<dd>Numpy RandomState random number generator instance.</dd>
<dt><strong><code>integration_transition</code></strong></dt>
<dd>Markov transition operator which jointly
updates the position and momentum components of the chain
state by integrating the Hamiltonian dynamics of the system
to propose new values for the state.</dd>
<dt><strong><code>momentum_transition</code></strong></dt>
<dd>Markov transition operator which updates only
the momentum component of the chain state. If set to <code>None</code> a
transition operator which independently samples the momentum
from its conditional distribution will be used.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L699-L738" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StaticMetropolisHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Static integration time H-MCMC implementation with Metropolis sampling.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a fixed integer number of integrator steps.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.

    This is original proposed Hybrid Monte Carlo (often now instead termed
    Hamiltonian Monte Carlo) algorithm [1,2].

    References:

      1. Duane, S., Kennedy, A.D., Pendleton, B.J. and Roweth, D., 1987.
         Hybrid Monte Carlo. Physics letters B, 195(2), pp.216-222.
      2. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng, n_step,
                 momentum_transition=None):
        integration_transition = trans.MetropolisStaticIntegrationTransition(
            system, integrator, n_step)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def n_step(self):
        return self.transitions[&#39;integration_transition&#39;].n_step

    @n_step.setter
    def n_step(self, value):
        self.transitions[&#39;integration_transition&#39;].n_step = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></li>
<li><a title="mici.samplers.MarkovChainMonteCarloMethod" href="#mici.samplers.MarkovChainMonteCarloMethod">MarkovChainMonteCarloMethod</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.samplers.StaticMetropolisHMC.n_step"><code class="name">var <span class="ident">n_step</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L732-L734" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def n_step(self):
    return self.transitions[&#39;integration_transition&#39;].n_step</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.samplers.StaticMetropolisHMC.sample_chain"><code class="name flex">
<span>def <span class="ident">sample_chain</span></span>(<span>self, n_sample, init_state, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chain" href="#mici.samplers.HamiltonianMCMC.sample_chain">sample_chain</a></code>
</p>
<section class="desc inherited"><p>Sample a Markov chain from a given initial state …</p></section>
</dd>
<dt id="mici.samplers.StaticMetropolisHMC.sample_chains"><code class="name flex">
<span>def <span class="ident">sample_chains</span></span>(<span>self, n_sample, init_states, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chains" href="#mici.samplers.HamiltonianMCMC.sample_chains">sample_chains</a></code>
</p>
<section class="desc inherited"><p>Sample one or more Markov chains from given initial states …</p></section>
</dd>
</dl>
</dd>
<dt id="mici.samplers.RandomMetropolisHMC"><code class="flex name class">
<span>class <span class="ident">RandomMetropolisHMC</span></span>
<span>(</span><span>system, integrator, rng, n_step_range, momentum_transition=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Random integration time H-MCMC with Metropolis sampling of new state.</p>
<p>In each transition a trajectory is generated by integrating the Hamiltonian
dynamics from the current state in the current integration time direction
for a random integer number of integrator steps sampled from the uniform
distribution on an integer interval.</p>
<p>The state at the end of the trajectory with the integration direction
negated (this ensuring the proposed move is an involution) is used as the
proposal in a Metropolis acceptance step. The integration direction is then
deterministically negated again irrespective of the accept decision, with
the effect being that on acceptance the integration direction will be equal
to its initial value and on rejection the integration direction will be
the negation of its initial value.</p>
<p>The randomisation of the number of integration steps avoids the potential
of the chain mixing poorly due to using an integration time close to the
period of (near) periodic systems [1,2].</p>
<h2 id="references">References</h2>
<ol>
<li>Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
Handbook of Markov Chain Monte Carlo, 2(11), p.2.</li>
<li>Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
Physics Letters B, 226(3-4), pp.369-371.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>rng</code></strong></dt>
<dd>Numpy RandomState random number generator instance.</dd>
<dt><strong><code>integration_transition</code></strong></dt>
<dd>Markov transition operator which jointly
updates the position and momentum components of the chain
state by integrating the Hamiltonian dynamics of the system
to propose new values for the state.</dd>
<dt><strong><code>momentum_transition</code></strong></dt>
<dd>Markov transition operator which updates only
the momentum component of the chain state. If set to <code>None</code> a
transition operator which independently samples the momentum
from its conditional distribution will be used.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L741-L782" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RandomMetropolisHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Random integration time H-MCMC with Metropolis sampling of new state.

    In each transition a trajectory is generated by integrating the Hamiltonian
    dynamics from the current state in the current integration time direction
    for a random integer number of integrator steps sampled from the uniform
    distribution on an integer interval.

    The state at the end of the trajectory with the integration direction
    negated (this ensuring the proposed move is an involution) is used as the
    proposal in a Metropolis acceptance step. The integration direction is then
    deterministically negated again irrespective of the accept decision, with
    the effect being that on acceptance the integration direction will be equal
    to its initial value and on rejection the integration direction will be
    the negation of its initial value.

    The randomisation of the number of integration steps avoids the potential
    of the chain mixing poorly due to using an integration time close to the
    period of (near) periodic systems [1,2].

    References:

      1. Neal, R.M., 2011. MCMC using Hamiltonian dynamics.
         Handbook of Markov Chain Monte Carlo, 2(11), p.2.
      2. Mackenzie, P.B., 1989. An improved hybrid Monte Carlo method.
         Physics Letters B, 226(3-4), pp.369-371.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng, n_step_range,
                 momentum_transition=None):
        integration_transition = trans.MetropolisRandomIntegrationTransition(
            system, integrator, n_step_range)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def n_step_range(self):
        return self.transitions[&#39;integration_transition&#39;].n_step_range

    @n_step_range.setter
    def n_step_range(self, value):
        self.transitions[&#39;integration_transition&#39;].n_step_range = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></li>
<li><a title="mici.samplers.MarkovChainMonteCarloMethod" href="#mici.samplers.MarkovChainMonteCarloMethod">MarkovChainMonteCarloMethod</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.samplers.RandomMetropolisHMC.n_step_range"><code class="name">var <span class="ident">n_step_range</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L776-L778" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def n_step_range(self):
    return self.transitions[&#39;integration_transition&#39;].n_step_range</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.samplers.RandomMetropolisHMC.sample_chain"><code class="name flex">
<span>def <span class="ident">sample_chain</span></span>(<span>self, n_sample, init_state, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chain" href="#mici.samplers.HamiltonianMCMC.sample_chain">sample_chain</a></code>
</p>
<section class="desc inherited"><p>Sample a Markov chain from a given initial state …</p></section>
</dd>
<dt id="mici.samplers.RandomMetropolisHMC.sample_chains"><code class="name flex">
<span>def <span class="ident">sample_chains</span></span>(<span>self, n_sample, init_states, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chains" href="#mici.samplers.HamiltonianMCMC.sample_chains">sample_chains</a></code>
</p>
<section class="desc inherited"><p>Sample one or more Markov chains from given initial states …</p></section>
</dd>
</dl>
</dd>
<dt id="mici.samplers.DynamicMultinomialHMC"><code class="flex name class">
<span>class <span class="ident">DynamicMultinomialHMC</span></span>
<span>(</span><span>system, integrator, rng, max_tree_depth=10, max_delta_h=1000, termination_criterion=&lt;function riemannian_no_u_turn_criterion&gt;, momentum_transition=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Dynamic integration time H-MCMC with multinomial sampling of new state.</p>
<p>In each transition a binary tree of states is recursively computed by
integrating randomly forward and backward in time by a number of steps
equal to the previous tree size [1,2] until a termination criteria on the
tree leaves is met. The next chain state is chosen from the candidate
states using a progressive multinomial sampling scheme [2] based on the
relative probability densities of the different candidate states, with the
resampling biased towards states further from the current state.</p>
<h2 id="references">References</h2>
<ol>
<li>Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
Journal of Machine Learning Research, 15(1), pp.1593-1623.</li>
<li>Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
Carlo. arXiv preprint arXiv:1701.02434.</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system</code></strong></dt>
<dd>Hamiltonian system to be simulated.</dd>
<dt><strong><code>rng</code></strong></dt>
<dd>Numpy RandomState random number generator instance.</dd>
<dt><strong><code>integration_transition</code></strong></dt>
<dd>Markov transition operator which jointly
updates the position and momentum components of the chain
state by integrating the Hamiltonian dynamics of the system
to propose new values for the state.</dd>
<dt><strong><code>momentum_transition</code></strong></dt>
<dd>Markov transition operator which updates only
the momentum component of the chain state. If set to <code>None</code> a
transition operator which independently samples the momentum
from its conditional distribution will be used.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L785-L829" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DynamicMultinomialHMC(HamiltonianMCMC):
    &#34;&#34;&#34;Dynamic integration time H-MCMC with multinomial sampling of new state.

    In each transition a binary tree of states is recursively computed by
    integrating randomly forward and backward in time by a number of steps
    equal to the previous tree size [1,2] until a termination criteria on the
    tree leaves is met. The next chain state is chosen from the candidate
    states using a progressive multinomial sampling scheme [2] based on the
    relative probability densities of the different candidate states, with the
    resampling biased towards states further from the current state.

    References:

      1. Hoffman, M.D. and Gelman, A., 2014. The No-U-turn sampler:
         adaptively setting path lengths in Hamiltonian Monte Carlo.
         Journal of Machine Learning Research, 15(1), pp.1593-1623.
      2. Betancourt, M., 2017. A conceptual introduction to Hamiltonian Monte
         Carlo. arXiv preprint arXiv:1701.02434.
    &#34;&#34;&#34;

    def __init__(self, system, integrator, rng,
                 max_tree_depth=10, max_delta_h=1000,
                 termination_criterion=trans.riemannian_no_u_turn_criterion,
                 momentum_transition=None):
        integration_transition = trans.MultinomialDynamicIntegrationTransition(
            system, integrator, max_tree_depth, max_delta_h,
            termination_criterion)
        super().__init__(system, rng, integration_transition,
                         momentum_transition)

    @property
    def max_tree_depth(self):
        return self.transitions[&#39;integration_transition&#39;].max_tree_depth

    @max_tree_depth.setter
    def max_tree_depth(self, value):
        self.transitions[&#39;integration_transition&#39;].max_tree_depth = value

    @property
    def max_delta_h(self):
        return self.transitions[&#39;integration_transition&#39;].max_delta_h

    @max_delta_h.setter
    def max_delta_h(self, value):
        self.transitions[&#39;integration_transition&#39;].max_delta_h = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></li>
<li><a title="mici.samplers.MarkovChainMonteCarloMethod" href="#mici.samplers.MarkovChainMonteCarloMethod">MarkovChainMonteCarloMethod</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mici.samplers.DynamicMultinomialHMC.max_tree_depth"><code class="name">var <span class="ident">max_tree_depth</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L815-L817" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def max_tree_depth(self):
    return self.transitions[&#39;integration_transition&#39;].max_tree_depth</code></pre>
</details>
</dd>
<dt id="mici.samplers.DynamicMultinomialHMC.max_delta_h"><code class="name">var <span class="ident">max_delta_h</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/matt-graham/mici/blob/24c0527d88a4781727b5213d55b4c21767956bcf/mici/samplers.py#L823-L825" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def max_delta_h(self):
    return self.transitions[&#39;integration_transition&#39;].max_delta_h</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mici.samplers.DynamicMultinomialHMC.sample_chain"><code class="name flex">
<span>def <span class="ident">sample_chain</span></span>(<span>self, n_sample, init_state, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chain" href="#mici.samplers.HamiltonianMCMC.sample_chain">sample_chain</a></code>
</p>
<section class="desc inherited"><p>Sample a Markov chain from a given initial state …</p></section>
</dd>
<dt id="mici.samplers.DynamicMultinomialHMC.sample_chains"><code class="name flex">
<span>def <span class="ident">sample_chains</span></span>(<span>self, n_sample, init_states, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code>.<code><a title="mici.samplers.HamiltonianMCMC.sample_chains" href="#mici.samplers.HamiltonianMCMC.sample_chains">sample_chains</a></code>
</p>
<section class="desc inherited"><p>Sample one or more Markov chains from given initial states …</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="mici docs home" href="index.html">
<img width="400" src="../logo.png" alt="mici">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Package</h3>
<ul>
<li><code><a title="mici" href="index.html">mici</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mici.samplers.MarkovChainMonteCarloMethod" href="#mici.samplers.MarkovChainMonteCarloMethod">MarkovChainMonteCarloMethod</a></code></h4>
<ul class="">
<li><code><a title="mici.samplers.MarkovChainMonteCarloMethod.sample_chain" href="#mici.samplers.MarkovChainMonteCarloMethod.sample_chain">sample_chain</a></code></li>
<li><code><a title="mici.samplers.MarkovChainMonteCarloMethod.sample_chains" href="#mici.samplers.MarkovChainMonteCarloMethod.sample_chains">sample_chains</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.samplers.HamiltonianMCMC" href="#mici.samplers.HamiltonianMCMC">HamiltonianMCMC</a></code></h4>
<ul class="">
<li><code><a title="mici.samplers.HamiltonianMCMC.sample_chain" href="#mici.samplers.HamiltonianMCMC.sample_chain">sample_chain</a></code></li>
<li><code><a title="mici.samplers.HamiltonianMCMC.sample_chains" href="#mici.samplers.HamiltonianMCMC.sample_chains">sample_chains</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.samplers.StaticMetropolisHMC" href="#mici.samplers.StaticMetropolisHMC">StaticMetropolisHMC</a></code></h4>
<ul class="">
<li><code><a title="mici.samplers.StaticMetropolisHMC.sample_chain" href="#mici.samplers.StaticMetropolisHMC.sample_chain">sample_chain</a></code></li>
<li><code><a title="mici.samplers.StaticMetropolisHMC.sample_chains" href="#mici.samplers.StaticMetropolisHMC.sample_chains">sample_chains</a></code></li>
<li><code><a title="mici.samplers.StaticMetropolisHMC.n_step" href="#mici.samplers.StaticMetropolisHMC.n_step">n_step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.samplers.RandomMetropolisHMC" href="#mici.samplers.RandomMetropolisHMC">RandomMetropolisHMC</a></code></h4>
<ul class="">
<li><code><a title="mici.samplers.RandomMetropolisHMC.sample_chain" href="#mici.samplers.RandomMetropolisHMC.sample_chain">sample_chain</a></code></li>
<li><code><a title="mici.samplers.RandomMetropolisHMC.sample_chains" href="#mici.samplers.RandomMetropolisHMC.sample_chains">sample_chains</a></code></li>
<li><code><a title="mici.samplers.RandomMetropolisHMC.n_step_range" href="#mici.samplers.RandomMetropolisHMC.n_step_range">n_step_range</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mici.samplers.DynamicMultinomialHMC" href="#mici.samplers.DynamicMultinomialHMC">DynamicMultinomialHMC</a></code></h4>
<ul class="">
<li><code><a title="mici.samplers.DynamicMultinomialHMC.sample_chain" href="#mici.samplers.DynamicMultinomialHMC.sample_chain">sample_chain</a></code></li>
<li><code><a title="mici.samplers.DynamicMultinomialHMC.sample_chains" href="#mici.samplers.DynamicMultinomialHMC.sample_chains">sample_chains</a></code></li>
<li><code><a title="mici.samplers.DynamicMultinomialHMC.max_tree_depth" href="#mici.samplers.DynamicMultinomialHMC.max_tree_depth">max_tree_depth</a></code></li>
<li><code><a title="mici.samplers.DynamicMultinomialHMC.max_delta_h" href="#mici.samplers.DynamicMultinomialHMC.max_delta_h">max_delta_h</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
Copyright © 2019 Matt Graham
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>